---
title: "Accelerate OpenCV on Windows with CUDA and Python"
toc: true
---

![](imgs/opencv_cuda_intel.webp){fig-align="center"}

# Why manually build OpenCV?

Because the pre-built [Windows libraries](https://github.com/opencv/opencv/releases) available for [OpenCV](https://opencv.org/releases) do not include the [CUDA modules](https://docs.opencv.org/4.x/d1/d1e/group__cuda.html), or support for the Nvidia [Video Codec SDK](https://developer.nvidia.com/nvidia-video-codec-sdk) or [cuDNN](https://developer.nvidia.com/cudnn), I have included the build instructions in the guide below for anyone who is interested. The guide includes instructions for compiling the 64 bit version of the OpenCV shared libraries with Visual Studio, [CUDA](https://developer.nvidia.com/cuda-toolkit/whatsnew) (optionally the [Nvidia Video Codec SDK](https://developer.nvidia.com/nvidia-video-codec-sdk) and [cuDNN](https://developer.nvidia.com/cudnn)), and bindings for accessing the OpenCV CUDA modules from within Python.

If you just need the Windows libraries or a Python Wheel you may not need to look any futher as I may have provided a pre-buit version which is suitable for your setup.  Take a look at [OpenCV C++ CUDA Builds](https://github.com/cudawarped/opencv_contrib/releases) and/or [OpenCV python CUDA wheels](https://github.com/cudawarped/opencv-python-cuda-wheels/releases) to see if this is the case.

To see if building the OpenCV CUDA modules is suitable for your application you can get an indication of the performance boost of most functions in [OpenCV CUDA Performance Comparisson (Nvidia vs Intel)](opencv_cuda_performance.qmd).

# Pre-build checklist

**Before continuing there are a few things to be aware of:**  

1. This guide assumes you are building the latest stable release of OpenCV against the most recent CUDA dependencies.  Whilst the instructions can also work on older versions, this is not guaranteed so please update to the latest stable releases before raising any issues.

2. If you just need the OpenCV binaries or a Python Wheel which includes the CUDA modules, check <a href="https://github.com/cudawarped/opencv_contrib/releases" target="_blank" rel="noopener noreferrer">OpenCV C++ CUDA Builds</a> and/or [OpenCV python CUDA wheels](https://github.com/cudawarped/opencv-python-cuda-wheels/releases) first to see if they are available for your desired combination of OpenCV and CUDA.

3. If you have previously built and/or are trying to manually install the Python bindings and are facing errors check out the [troubleshooting Python bindings installation issues](#troubleshooting-python-bindings-installation-issues) and [manually installing OpenCV Python bindings](#manually-installing-opencv-python-bindings) sections first.

4. If you already have the OpenCV source and the required dependencies and are just looking for the CMake flags  they can be found [here](#opencv-cuda-python-windows-cmake-flags).

# Prerequisites
There are a couple of components you need to download and/or install before you can get started, you first need to:

 1. Install the latest version of <a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community" target="_blank" rel="noopener noreferrer">Visual Studio</a>, selecting the **Desktop development with C++** workload shown in the image below. If you already have an installation ensure that the correct workload is installed and that you have updated to the latest version.

    ![Visual Studio Select C++ Workload](imgs/vs_community_c++_workload.png){fig-align="center"}

[I have seen lots of guides including instructions to download and use git to get the source files, however this is a completely unnecessary step. If you are a developer and you don't already have git installed and configured then I would assume there is a good reason for this and I would not advise installing it just to build OpenCV.]{.aside}

2. Download the source files for OpenCV from [GitHub](https://github.com/opencv) by either cloning the repositories ([opencv](https://github.com/opencv/opencv) and [opencv_contrib](https://github.com/opencv/opencv_contrib)) or or downloading the archives containing the source files ([opencv.zip](https://github.com/opencv/opencv/archive/refs/heads/4.x.zip) and [opencv_contirib.zip](https://github.com/opencv/opencv_contrib/archive/refs/heads/4.x.zip))

3. Install the latest stable (not release candidate -rc) version of <a href="https://cmake.org/download/" target="_blank" rel="noopener noreferrer">CMake</a>.

4. Install the latest version of the <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener noreferrer">CUDA Toolkit</a>.

::: {.callout-important .callout-note appearance="simple"}
If your system path is too long, CUDA will not add the path to its shared libraries `C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vxx.x\bin` during installation.  If you receive a warning about this at the end of the installation process do not forget to manually add the this to your system or user path.
:::

[Before building you may want to ensure that your GPU has decoding support by refering to <a href="https://developer.nvidia.com/video-encode-decode-gpu-support-matrix#Decoder" rel="noopener noreferrer" target="_blank">Nvidia Video Decoder Support Matrix</a>]{.aside}

5. **Optional** - To **decode** video on the GPU with the <a href="https://developer.nvidia.com/nvidia-video-codec-sdk" target="_blank" rel="noopener noreferrer">Nvidia Video Codec SDK</a>:
    i) Register and <a href="https://developer.nvidia.com/nvidia-video-codec-sdk#Download" target="_blank" rel="noopener noreferrer">download</a> the latest version of the Video Codec SDK.
    ii) Extract and copy the contents of **Interface** and **Lib**  to the **include** and **lib** directories inside your CUDA installation.

6. **Optional** - To use the DNN CUDA backend:
    i) Register and <a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" target="_blank" rel="noopener noreferrer">download</a> cuDNN.</li>

    ii) Extract and copy the **bin**, **include** and **lib** directories to your CUDA installation.

::: {.callout-tip}
The installation directory for CUDA xx.x is
`C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vxx.x`.
:::

[All python distributions should work however I recommend building and testing against a new install of this compact distribution to avoid any problems caused by existing configurations.]{.aside}

7. **Optional** – To call OpenCV CUDA routines from python, install the latest x64 bit version of [mambaforge](https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-Windows-x86_64.exe).

# Building OpenCV with CMake

[If you have any build issues with OpenCV then you will need to provide the arguments passed to CMake as well as the output from the generation step when asking for assistance so it is a good idea to avoid the CMake gui at this stage.]{.aside}
Before you can build OpenCV you have to generate the build files with CMake. This can be done via the command line or with the CMake GUI.  Most new users will find the GUI more accessable however by far the quickest, easiest and least error prone way to proceed is to call CMake from the command line and as a result I have not included any instructions on using the CMake GUI in this guide.

In addition there are several ways to build OpenCV using Visual Studio. For simplicity only two methods are discussed:

1. [Building OpenCV with Visual Studio solution files](#building-opencv-with-cuda-using-visual-studio-solution-files-from-the-command-prompt-cmd).
2. [Building OpenCV with the ninja build system to reduce the build time](#decreasing-the-build-time-with-ninja).

## Building OpenCV with CUDA using Visual Studio solution files from the command prompt (cmd)

 The following steps will build the `opencv_worldxxx.dll` using NVIDIA's recommended settings for future hardware compatibility. This does however have two drawbacks, first the build can take several hours to complete and second, the shared library can be over 1GB depending on the configuration that you choose. To find out how to reduce both the compilation time and size of `opencv_worldxxx.dll` read [choosing a suitable CUDA compute capability](#choosing-the-cuda-compute-capability) first and then continue as below. Additionally to reduce the build time futher you can use the Ninja build system, see [building OpenCV with the ninja build system to reduce the build time](#decreasing-the-build-time-with-ninja)

1. Open windows command prompt, type **cmd** in the search bar.
1. Paste the below into to the command prompt and press **Enter**.

    [An additionaly option you may want to include is `-DCUDA_FAST_MATH=ON` which compiles the CUDA kernels with the [-use_fast_math](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html?highlight=use_fast_math#intrinsic-functions) option.  This will however cause some of the accuracy and performace tests to fail as the floating point results will be slightly less accurate.]{.aside}

    [To get the python version open the **MiniForge Prompt** from the start menu and type `Python -V`]{.aside}

    [If you get the following error "CUDA : OpenCV requires enabled 'cudev' module from 'opencv_contrib'" when configuring the build with CMake you have not set `OPENCV_EXTRA_MODULES_PATH` correctly, most likely you have set it to the root of the `opencv_contrib` repo and not the modules directory inside the repo.]{.aside}

    ```{.default .code-overflow-wrap #opencv-cuda-python-windows-cmake-flags}
    "C:\Program Files\CMake\bin\cmake.exe" -B"PATH_TO_BUILD_DIR" -H"PATH_TO_OPENCV_SOURCE" -DOPENCV_EXTRA_MODULES_PATH="PATH_TO_OPENCV_CONTRIB_MODULES" -G"Visual Studio 17 2022" -DINSTALL_TESTS=ON -DINSTALL_C_EXAMPLES=ON -DBUILD_EXAMPLES=ON -DBUILD_opencv_world=ON -DWITH_CUDA=ON -DWITH_CUBLAS=ON -DWITH_CUFFT=ON -DCUDA_ARCH_PTX=9.0 -DBUILD_opencv_python3=ON -DPYTHON3_INCLUDE_DIR=PATH_TO_PYTHON_DIST/include -DPYTHON3_LIBRARY=PATH_TO_PYTHON_DIST/libs/python%pyVer%.lib -DPYTHON3_EXECUTABLE=PATH_TO_PYTHON_DIST/python.exe -DPYTHON3_NUMPY_INCLUDE_DIRS=PATH_TO_PYTHON_DIST/lib/site-packages/numpy/core/include -DPYTHON3_PACKAGES_PATH=PATH_TO_PYTHON_DIST/Lib/site-packages/
    ```

    where
     i) **PATH_TO_OPENCV_SOURCE** is the root of the OpenCV files you downloaded or cloned (the directory containing 3rdparty, apps, build, etc.), 
     ii) **PATH_TO_OPENCV_CONTRIB_MODULES** is the path to the **modules** directory inside the <a href="https://github.com/opencv/opencv_contrib/tree/master/modules" target="_blank" rel="noopener noreferrer">opencv-contrib</a> repository (the directory containing cudaarithm, cudabgsegm, etc.),
     iii) **PATH_TO_BUILD_DIR** is the path to the directory where the build files should go and
     iv) **PATH_TO_PYTHON_DIST** is the directory where miniconda was installed and,
     v) **PYTHON_VERSION** is the concatination of the major and minor version of your python install, e.g. for Python 3.10.10 **PYTHON_VERSION**==310.

    This will build OpenCV and its python bindings with CUDA acceleration including all the corresponding tests and examples for verifcation. Additionally if the Nvidia Video Codec SDK or cuDNN are installed the corresponding modules will automatically be included.

    Expand the tip below for an example of the output you should get in CMake if the configuration step is successful.

::: {.callout-note collapse=true}

## Example of CMake Configuration Output
```{.default}
--
-- General configuration for OpenCV 4.7.0-dev =====================================
--   Version control:               4.7.0-252-g88a438e542
--
--   Extra modules:
--     Location (extra):            D:/repos/opencv/contrib/modules
--     Version control (extra):     4.7.0-42-ga42b8bef
--
--   Platform:
--     Timestamp:                   2023-05-03T10:21:52Z
--     Host:                        Windows 10.0.22621 AMD64
--     CMake:                       3.25.1
--     CMake generator:             Visual Studio 17 2022
--     CMake build tool:            C:/Program Files/Microsoft Visual Studio/2022/Community/MSBuild/Current/Bin/amd64/MSBuild.exe
--     MSVC:                        1934
--     Configuration:               Debug Release
--
--   CPU/HW features:
--     Baseline:                    SSE SSE2 SSE3
--       requested:                 SSE3
--     Dispatched code generation:  SSE4_1 SSE4_2 FP16 AVX AVX2 AVX512_SKX
--       requested:                 SSE4_1 SSE4_2 AVX FP16 AVX2 AVX512_SKX
--       SSE4_1 (18 files):         + SSSE3 SSE4_1
--       SSE4_2 (2 files):          + SSSE3 SSE4_1 POPCNT SSE4_2
--       FP16 (1 files):            + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 AVX
--       AVX (8 files):             + SSSE3 SSE4_1 POPCNT SSE4_2 AVX
--       AVX2 (36 files):           + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 FMA3 AVX AVX2
--       AVX512_SKX (8 files):      + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 FMA3 AVX AVX2 AVX_512F AVX512_COMMON AVX512_SKX
--
--   C/C++:
--     Built as dynamic libs?:      YES
--     C++ standard:                11
--     C++ Compiler:                C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe  (ver 19.34.31937.0)
--     C++ flags (Release):         /DWIN32 /D_WINDOWS /W4 /GR  /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi  /fp:precise     /EHa /wd4127 /wd4251 /wd4324 /wd4275 /wd4512 /wd4589 /wd4819 /MP  /MD /O2 /Ob2 /DNDEBUG
--     C++ flags (Debug):           /DWIN32 /D_WINDOWS /W4 /GR  /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi  /fp:precise     /EHa /wd4127 /wd4251 /wd4324 /wd4275 /wd4512 /wd4589 /wd4819 /MP  /MDd /Zi /Ob0 /Od /RTC1
--     C Compiler:                  C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.34.31933/bin/Hostx64/x64/cl.exe
--     C flags (Release):           /DWIN32 /D_WINDOWS /W3  /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi  /fp:precise     /MP   /MD /O2 /Ob2 /DNDEBUG
--     C flags (Debug):             /DWIN32 /D_WINDOWS /W3  /D _CRT_SECURE_NO_DEPRECATE /D _CRT_NONSTDC_NO_DEPRECATE /D _SCL_SECURE_NO_WARNINGS /Gy /bigobj /Oi  /fp:precise     /MP /MDd /Zi /Ob0 /Od /RTC1
--     Linker flags (Release):      /machine:x64  /INCREMENTAL:NO
--     Linker flags (Debug):        /machine:x64  /debug /INCREMENTAL
--     ccache:                      NO
--     Precompiled headers:         NO
--     Extra dependencies:          cudart_static.lib nppc.lib nppial.lib nppicc.lib nppicom.lib nppidei.lib nppif.lib nppig.lib nppim.lib nppist.lib nppisu.lib nppitc.lib npps.lib cublas.lib cufft.lib -LIBPATH:C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.2/lib/x64
--     3rdparty dependencies:
--
--   OpenCV modules:
--     To be built:                 aruco barcode bgsegm bioinspired calib3d ccalib core cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev datasets dnn dnn_objdetect dnn_superres dpm face features2d flann fuzzy gapi hfs highgui img_hash imgcodecs imgproc intensity_transform line_descriptor mcc ml objdetect optflow phase_unwrapping photo plot python3 quality rapid reg rgbd saliency shape stereo stitching structured_light superres surface_matching text tracking ts video videoio videostab wechat_qrcode world xfeatures2d ximgproc xobjdetect xphoto
--     Disabled:                    -
--     Disabled by dependency:      -
--     Unavailable:                 alphamat cvv freetype hdf java julia matlab ovis python2 python2 sfm viz
--     Applications:                tests perf_tests examples apps
--     Documentation:               NO
--     Non-free algorithms:         NO
--
--   Windows RT support:            NO
--
--   GUI:
--     Win32 UI:                    YES
--     VTK support:                 NO
--
--   Media I/O:
--     ZLib:                        build (ver 1.2.13)
--     JPEG:                        build-libjpeg-turbo (ver 2.1.3-62)
--       SIMD Support Request:      YES
--       SIMD Support:              NO
--     WEBP:                        build (ver encoder: 0x020f)
--     PNG:                         build (ver 1.6.37)
--     TIFF:                        build (ver 42 - 4.2.0)
--     JPEG 2000:                   build (ver 2.4.0)
--     OpenEXR:                     build (ver 2.3.0)
--     HDR:                         YES
--     SUNRASTER:                   YES
--     PXM:                         YES
--     PFM:                         YES
--
--   Video I/O:
--     DC1394:                      NO
--     FFMPEG:                      YES (prebuilt binaries)
--       avcodec:                   YES (58.134.100)
--       avformat:                  YES (58.76.100)
--       avutil:                    YES (56.70.100)
--       swscale:                   YES (5.9.100)
--       avresample:                YES (4.0.0)
--     GStreamer:                   NO
--     DirectShow:                  YES
--     Media Foundation:            YES
--       DXVA:                      YES
--
--   Parallel framework:            Concurrency
--
--   Trace:                         YES (with Intel ITT)
--
--   Other third-party libraries:
--     Intel IPP:                   2021.8 [2021.8.0]
--            at:                   D:/build/opencv/4_7_0/delete_this/3rdparty/ippicv/ippicv_win/icv
--     Intel IPP IW:                sources (2021.8.0)
--               at:                D:/build/opencv/4_7_0/delete_this/3rdparty/ippicv/ippicv_win/iw
--     Lapack:                      NO
--     Eigen:                       NO
--     Custom HAL:                  NO
--     Protobuf:                    build (3.19.1)
--     Flatbuffers:                 builtin/3rdparty (23.1.21)
--
--   NVIDIA CUDA:                   YES (ver 12.1, CUFFT CUBLAS NVCUVID NVCUVENC)
--     NVIDIA GPU arch:
--     NVIDIA PTX archs:            90
--
--   cuDNN:                         NO
--
--   OpenCL:                        YES (NVD3D11)
--     Include path:                D:/repos/opencv/opencv/3rdparty/include/opencl/1.2
--     Link libraries:              Dynamic load
--
--   Python 3:
--     Interpreter:                 C:/Users/username/mambaforge/python.exe (ver 3.9.16)
--     Libraries:                   C:/Users/username/mambaforge/libs/python39.lib (ver 3.9.16)
--     numpy:                       C:/Users/username/mambaforge/Lib/site-packages/numpy/core/include (ver 1.23.5)
--     install path:                C:/Users/username/mambaforge/Lib/site-packages/cv2/python-3.9
--
--   Python (for build):            C:/Users/username/mambaforge/python.exe
--
--   Java:
--     ant:                         NO
--     JNI:                         NO
--     Java wrappers:               NO
--     Java tests:                  NO
--
--   Install to:                    D:/build/opencv/4_7_0/install
-- -----------------------------------------------------------------
--
-- Configuring done
-- Generating done
-- Build files have been written to: D:/build/opencv/4_7_0
```
:::


::: {.callout-tip collapse=true appearance="default"}
## Only build cuDNN backend

If you just want to CUDA accelerate the DNN module and are not interested in building the rest of the CUDA modules the following can be added to the above command.

```{.default .code-overflow-wrap}
-DBUILD_opencv_cudaarithm=OFF -DBUILD_opencv_cudabgsegm=OFF -DBUILD_opencv_cudafeatures2d=OFF -DBUILD_opencv_cudafilters=OFF -DBUILD_opencv_cudaimgproc=OFF -DBUILD_opencv_cudalegacy=OFF -DBUILD_opencv_cudaobjdetect=OFF -DBUILD_opencv_cudaoptflow=OFF -DBUILD_opencv_cudastereo=OFF -DBUILD_opencv_cudawarping=OFF -DBUILD_opencv_cudacodec=OFF
```

This will significantly reduce compilation time and size of `opencv_worldxxx.dll`.
:::

::: {.callout-tip collapse=true appearance="default"}
## Build without python bindings
If you don't want to build python bindings then you can simply remove everything from `-DBUILD_opencv_python3` onwards in the above command.
:::

::: {.callout-tip collapse=true appearance="simple"}
## Verify configuration includes Python bindings before building
If you are building the python bindings look for **python3** in the **To be built:** section of your CMake configuration output and if its not present look for any python related errors in the output preceeding it. e.g.
```{.default .code-overflow-wrap}
--   OpenCV modules:
--     To be built:                 aruco bgsegm bioinspired calib3d ccalib core cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev datasets dnn dnn_objdetect dpm face features2d flann fuzzy hfs highgui img_hash imgcodecs imgproc line_descriptor ml objdetect optflow phase_unwrapping photo plot python2 python3 quality reg rgbd saliency shape stereo stitching structured_light superres surface_matching text tracking ts video videoio videostab world xfeatures2d ximgproc xobjdetect xphoto
```
:::

2. The **OpenCV.sln** solution file should now be in your **PATH_TO_BUILD_DIR** directory. To build OpenCV you have two options depending on you preference you can:
    i) Build directly from the command line by simply entering the following (swaping **Release** for **Debug** to build a release version)

        ```{.default .code-overflow-wrap}
        "C:\Program Files\CMake\bin\cmake.exe" --build PATH_TO_BUILD_DIR --target INSTALL --config Debug
        ```

    ii) Build through Visual Studio GUI by opening up the **OpenCV.sln** in Visual Studio, selecting your Configuration, clicking on **Solution Explorer**, expanding **MakeTargets**, right clicking on **INSTALL** and clicking **Build**.

        ![Visual Studio Build Solution](imgs/cmake_visual_studio_install.webp){fig-align="center"}

    Either approach will both build the library, install the Python bindings and copy the necessary redistributable parts to the install directory (**PATH_TO_BUILD_DIR/build/install** in this example). All that is required now to run any programs compiled against these libs is to add the directory containing opencv_worldxxx.dll to you user **path** environmental variable.

::: {.callout-important}
By default you have to build **Release** when generating python bindings, see for instructions on how to build **Debug** see [generate python bindings for a debug build](#generate-python-bindings-for-a-debug-build)
:::

If everything was successful, congratulations, you now have OpenCV built with CUDA. To quickly verify that the CUDA modules are working and check if there is any performance benefit on your specific hardware see <a href="#cuda_performance">below</a>

## Decreasing the build time with Ninja

The build time for OpenCV can be reduced by more than 2x (from 2 hours to 30 mins on an i7-8700) by utilizing the Ninja build system instead of directly generating Visual Studio solution files.  The only difference you may notice is that Ninja will only produce one configuration at a time, either a `Debug` or `Release`, therefore if you don't want to build `Release` (the default) the `CMAKE_BUILD_TYPE` has to be passed to CMake.

Ninja is installed by default if the **Desktop development with C++** workload is selected when installing Visual Studio, therefore building with Ninja only requires two extra configuration steps, expand the tip below for an example of the modified command line arguments.:

1. Configuring Visual Studio Development tools by entering the following into the command prompt before entering the CMake command (changing Community to either Professional or Enterprise if necessary)

    ```{.default .code-overflow-wrap}
    "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
    ```

2. Telling CMake to use **Ninja** instead of Visual Studio, i.e. replacing `-G"Visual Studio 17 2022"` with `-GNinja`.

Once the build files have been generated the build can be kicked off in the same way as before but this time dropping the redundant `--config` argument.
```{.default .code-overflow-wrap}
"C:\Program Files\CMake\bin\cmake.exe" --build PATH_TO_BUILD_DIR --target INSTALL
```

::: {.callout-tip collapse="true"}
Example of the full command line for building a `Release` version of OpenCV with the Ninja build system.

```{.default .code-overflow-wrap}
"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
"C:\Program Files\CMake\bin\cmake.exe" -B"PATH_TO_BUILD_DIR" -H"PATH_TO_OPENCV_SOURCE" -DOPENCV_EXTRA_MODULES_PATH="PATH_TO_OPENCV_CONTRIB_MODULES" -G"Ninja" -DCMAKE_BUILD_TYPE=Release -DINSTALL_TESTS=ON -DINSTALL_C_EXAMPLES=ON -DBUILD_EXAMPLES=ON -DBUILD_opencv_world=ON -DWITH_CUDA=ON -DWITH_CUBLAS=ON -DCUDA_ARCH_PTX=8.6 -DBUILD_opencv_python3=ON -DPYTHON3_INCLUDE_DIR=PATH_TO_PYTHON_DIST include -DPYTHON3_LIBRARY=PATH_TO_PYTHON_DIST/libs/python%pyVer%.lib -DPYTHON3_EXECUTABLE=PATH_TO_PYTHON_DIST/python.exe -DPYTHON3_NUMPY_INCLUDE_DIRS=PATH_TO_PYTHON_DIST/lib/site-packages/numpy/core/include -DPYTHON3_PACKAGES_PATH=PATH_TO_PYTHON_DIST/Lib/site-packages/ -DOPENCV_SKIP_PYTHON_LOADER=ON
"C:\Program Files\CMake\bin\cmake.exe" --build PATH_TO_BUILD_DIR --target INSTALL
```
:::

# Verifying OpenCV is CUDA accelerated
The easiest way to quickly verify that everything is working is to check that one of the inbuilt CUDA performance tests passes. 

To run the CUDA performance test simply enter the following into the existing command prompt.

[The GEMM test is used in this example but any of the accuracy (`opencv_test_cuda*.exe`) or performance (`opencv_perf_cuda*.exe`) tests could have been chosen.]{.aside}

```{.default .code-overflow-wrap}
"PATH_TO_BUILD_DIR\bin\opencv_test_cudaarithm.exe" --gtest_filter=CUDA_Arithm/GEMM.Accuracy/0
```

To verify that everything is working look for the **[ PASSED ] 1 test** text, at the bottom of the test output, an example of which is below.

```{.default}
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from CUDA_Arithm/GEMM
[ RUN      ] CUDA_Arithm/GEMM.Accuracy/0, where GetParam() = (NVIDIA GeForce RTX 3070 Ti Laptop GPU, 128x128, 32FC1, 0, whole matrix)
[       OK ] CUDA_Arithm/GEMM.Accuracy/0 (1038 ms)
[----------] 1 test from CUDA_Arithm/GEMM (1039 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (1041 ms total)
[  PASSED  ] 1 test.
```

If the test has passed then we can confirm that the OpenCV build inside **PATH_TO_BUILD_DIR** includes the CUDA modules.

# Python bindings

The instructions above will enable you to build a `Release` version of OpenCV with bindings for python and automatically install them into your `PATH_TO_PYTHON_DIST/site-packages\cv2` directory.  You can then import the OpenCV python module (cv2) as

```{.default .code-overflow-wrap}
import cv2 as cv
```

and you should see  output similar to the below when interrogating the build information

```{.default}
print(cv.getBuildInformation())
General configuration for OpenCV 4.7.0-dev =====================================
  Version control:               4.7.0-251-ge3e1f704a4-dirty

  Extra modules:
    Location (extra):            D:/repos/opencv/contrib/modules
    Version control (extra):     4.7.0-38-g960b3f68

  Platform:
    Timestamp:                   2023-03-21T15:46:23Z
    Host:                        Windows 10.0.22621 AMD64
    CMake:                       3.25.1
    CMake generator:             Ninja
    CMake build tool:            D:/bin/ninja/ninja.exe
    MSVC:                        1934
    Configuration:               Release
    ...
```

That said you may:

1. Want to build bindings for a `Debug` as well or instead of a `Release` build.
2. Encounter errors when trying to import the `cv2` module in python.

Both of these scenarios are covered in the next three sections.

## Generate Python bindings for a Debug Build
Python bindings cannot by default be generated for a `Debug` configuration, that is unless you have specificaly built or downloaded a debug version of python. That said you can easily generate a `Debug` build by modifying the contents of `PATH_TO_PYTHON_DIST/include/pyconfig.h`, changing
```{.default .code-overflow-wrap}
pragma comment(lib,"pythonxx_d.lib")
```
to
```{.cpp .code-overflow-wrap}
pragma comment(lib,"pythonxx.lib")
```
and
```{.cpp .code-overflow-wrap}
#       define Py_DEBUG
```
to
```{.cpp .code-overflow-wrap}
//#       define Py_DEBUG
```

## Troubleshooting Python Bindings Installation issues
If you are unable to `import cv2` without errors then check below to see

1. > ModuleNotFoundError: No module named 'cv2'

    The installation of the python bindings has failed, check

    i) the build was successful, and
    ii) `-DPYTHON3_PACKAGES_PATH=PATH_TO_PYTHON_DIST/Lib/site-packages/` was set correctly, and
    iii) if you are still seeing the above error try installing the bindings manually following

2. > ImportError: ERROR: recursion is detected during loading of "cv2" binary extensions. Check OpenCV installation.

    The main two reasons for this are:
    i) You have another installation of OpenCV, either manually installed or through the package manager pip/mamba.  This can easily be fixed by first uninstalling any opencv-python distributions from your package manager and then deleting the ... directory or .... if they existing
    ii) You have built a `Debug` configuration.  Currently (see issue) when building this configuration the .pyd is not copied into.  This can be resolved by creating a .. and copyting the pyd.

3. > ImportError: DLL load failed: The specified procedure could not be found.

    The directory of one or more of the required DLL’s has not been added with [os.add_dll_directory](https://docs.python.org/3/library/os.html#os.add_dll_directory). Whilst the automatic installation of the bindings should have added all the directories containing the dependant DLL's to `config.py` its possible that one has been missed or you are using a less common configuration.  In these cases you will have to
    i) first track down which DLL's are missing ([see this guide for assistance](nbs/ImportError_dll_load_failed_while_importing_cv2.html)) and then 
    ii) permanantly add the directory containing them to your installation by modifying the contents of `PATH_TO_PYTHON_DIST/Lib/site-packages/cv2/config.py`.
    
    e.g. If you  built OpenCV against CUDA 12.1 and your own version of the FFMpeg libraries (`-DOPENCV_FFMPEG_USE_FIND_PACKAGE=ON`) instead of the provided `opencv_videoio_ffmpegxxx_64.dll` the contents of `config.py` should look like

    ```{.python}
    import os

    BINARIES_PATHS = [
        os.path.join('D:/build/opencv/install', 'x64/vc17/bin'),
        os.path.join(os.getenv('CUDA_PATH', 'C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1'), 'bin')
        os.path.join(`D:/ffmpeg/bin`)
    ] + BINARIES_PATHS
    ```

## Manually installing OpenCV Python bindings

If you have downloaded the pre-built binaries or are having issues with the automatic installation then you can  manually install the python bindings following the steps below:

1. Copy

    > PATH_TO_BUILD_DIR/lib/python3/cv2.cpxx-win_amd64.pyd

    to

    > PATH_TO_PYTHON_DIST/Lib/site-packages/cv2.cpxx-win_amd64.pyd
2. Determine the paths to the directories containing any dependant shared libraries ([see here for assistance](nbs/ImportError_dll_load_failed_while_importing_cv2.html)).  

3. Adding the locations from (2) by calling `os.add_dll_directory()` for each one before importing the OpenCV python module.  e.g. If you have followed the guide exactly this will just be the directories containing the OpenCV and Nvidia shared libaries, which you would add as

    ```{.python  .code-overflow-wrap}
    import os
    os.add_dll_directory('C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\vxx.x\\bin')
    os.add_dll_directory('PATH_TO_BUILD_DIR/bin')
    ```
    before calling

    ```{.python  .code-overflow-wrap}
    import cv2 as cv
    ```

# Choosing the a suitable CUDA compute capability






.  In this case you simply need to use the below before importing

From the feedback I have received it is most likely you have not added the location of either the OpenCV shared libraries (opencv_world450.dll and opencv_img_hash440.dll), the path to the CUDA binaries, or the path to tbb.dll if built with Intel TBB. This can be quickly checked by entering in the following


## Tips
If you change your CMake arguments and you start getting build errors clean everything



Remove all optional CUDA modules.  This is useful if you only want to use the CUDA backend for the DNN module and will significantly reduce compilation time and size of opencv_worldxxx.dll.

```
-DBUILD_opencv_cudaarithm=OFF -DBUILD_opencv_cudabgsegm=OFF -DBUILD_opencv_cudafeatures2d=OFF -DBUILD_opencv_cudafilters=OFF -DBUILD_opencv_cudaimgproc=OFF -DBUILD_opencv_cudalegacy=OFF -DBUILD_opencv_cudaobjdetect=OFF -DBUILD_opencv_cudaoptflow=OFF -DBUILD_opencv_cudastereo=OFF -DBUILD_opencv_cudawarping=OFF -DBUILD_opencv_cudacodec=OFF
```

    ```{.python .code-overflow-wrap}
    set "openCvSource=PATH_TO_OPENCV_SOURCE"
    set "openCVExtraModules=PATH_TO_OPENCV_CONTRIB_MODULES"
    set "openCvBuild=%openCvSource%\build"
    set "buildType=Release"
    set "generator=Visual Studio 16 2019"
    ```

### Troubleshooting

::: {.callout-tip}
If you don't want to build python bindings then simply remove...
:::

different version of python


[I have seen lots of guides including instructions to download and use git to get the source files, however this is a completely unnecessary step. If you are a developer and you don't already have git installed and configured then I would assume there is a good reason for this and I would not advise installing it just to build OpenCV.]{.aside}

::: {.callout-note collapse=true}
Before building you may want to ensure that your GPU has decoding support by refering to <a href="https://developer.nvidia.com/video-encode-decode-gpu-support-matrix#Decoder" rel="noopener noreferrer" target="_blank">Nvidia Video Decoder Support Matrix</a>
:::



where `PATH_TO_OPENCV_SOURCE` is the root of the OpenCV files you downloaded or cloned (the directory containing 3rdparty, apps, build, etc., `PATH_TO_OPENCV_CONTRIB_MODULES` is the path to the **modules** directory inside the <a href="https://github.com/opencv/opencv_contrib/tree/master/modules" target="_blank" rel="noopener noreferrer">opencv-contrib repo</a> (the directory containing cudaarithm, cudabgsegm, etc), `PATH_TO_BUILD_DIR` is the path to the directory where the build files should go and `PATH_TO_PYTHON_DIST` is the directory where miniconda was installed and `PYTHON_VERSION` is the concatination of the major and minor version of your python install, e.g. for Python 3.10.10 `PYTHON_VERSION=310`.

    This will build OpenCV with CUDA including and the corresponding tests and examples for verifcation. Additionally if the Nvidia Video Codec SDK or cuDNN are installed the corresponding modules will automatically be included

    1. Set the location of the source files and build directory, by entering the text shown below, first setting `PATH_TO_OPENCV_SOURCE` to the root of the OpenCV files you downloaded or cloned (the directory containing 3rdparty, apps, build, etc.) and `PATH_TO_OPENCV_CONTRIB_MODULES` to the **modules** directory inside the <a href="https://github.com/opencv/opencv_contrib/tree/master/modules" target="_blank" rel="noopener noreferrer">opencv-contrib repo</a> (the directory containing cudaarithm, cudabgsegm, etc).

    ```{.python .code-overflow-wrap}
    set "openCvSource=PATH_TO_OPENCV_SOURCE"
    set "openCVExtraModules=PATH_TO_OPENCV_CONTRIB_MODULES"
    set "openCvBuild=%openCvSource%\build"
    set "buildType=Release"
    set "generator=Visual Studio 16 2019"
    ```

    ```{.python .code-overflow-wrap}
    set "openCvSource=PATH_TO_OPENCV_SOURCE"
    set "openCVExtraModules=PATH_TO_OPENCV_CONTRIB_MODULES"
    set "openCvBuild=%openCvSource%\build"
    set "buildType=Release"
    set "generator=Visual Studio 16 2019"
    ```